from collections import defaultdict
from itertools import product
import os
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

from dwave.system import DWaveSampler, EmbeddingComposite

# Set the environment variable for your DWave API token
dwave_api_path = '/Users/arsmith/Desktop/dwave_api_token.txt'
with open(dwave_api_path, 'r') as f:
    os.environ['DWAVE_API_TOKEN'] = f.readline()

provinces = {
    0: 'Yukon',
    1: 'British Columbia',
    2: 'Northwest Territories',
    3: 'Alberta',
    4: 'Nunavut',
    5: 'Saskatchewan',
    6: 'Manitoba',
    7: 'Ontario',
    8: 'Quebec',
    9: 'Newfoundland and Labrador',
    10: 'New Brunswick',
    11: 'Nova Scotia',
    12: 'Prince Edward Island',
}
edges = [
    (0, 1),
    (0, 2),
    (1, 2),
    (1, 3),
    (2, 3),
    (2, 4),
    (2, 5),
    (3, 5),
    (4, 5),
    (4, 6),
    (4, 8),
    (5, 6),
    (6, 7),
    (7, 8),
    (8, 9),
    (8, 10),
    (8, 12),
    (9, 11),
    (9, 12),
    (10, 11),
    (10, 12),
    (11, 12),
]
graph = nx.Graph()
graph.add_edges_from(edges)

n_colours = 4
n_regions = len(graph.nodes)

A, B = 3, 1  # H = A * H_single + B * H_adj

# Linear coefficients come from H_single
linear_coefficients = {indices: 2 * (n_colours - 2) * A for indices in product(range(n_regions), range(n_colours))}

quadratic_coefficients = defaultdict(lambda: 0)
# Add the coefficients from H_single
for i in range(n_regions):
    for k in range(n_colours):
        for j in range(k + 1, n_colours):
            quadratic_coefficients[((i, k), (i, j))] += 2 * A

# Add the coefficients from H_adj
for i, j in graph.edges:
    for k in range(n_colours):
        quadratic_coefficients[((i, k), (j, k))] += 1 * B


# sampler = DWaveSampler(solver={'qpu': True})
# sampler_embedded = EmbeddingComposite(sampler)
# response = sampler_embedded.sample_ising(linear_coefficients, quadratic_coefficients, num_reads=500)

# best_solution = response.first.sample


# fmt: off
# Invalid solutions
best_solution50 = {(0, 0): -1, (0, 1): 1, (0, 2): -1, (0, 3): -1, (1, 0): -1, (1, 1): -1, (1, 2): -1, (1, 3): 1, (2, 0): 1, (2, 1): -1, (2, 2): -1, (2, 3): -1, (3, 0): -1, (3, 1): -1, (3, 2): 1, (3, 3): -1, (4, 0): -1, (4, 1): -1, (4, 2): -1, (4, 3): 1, (5, 0): 1, (5, 1): -1, (5, 2): -1, (5, 3): -1, (6, 0): -1, (6, 1): -1, (6, 2): 1, (6, 3): -1, (7, 0): -1, (7, 1): 1, (7, 2): -1, (7, 3): -1, (8, 0): -1, (8, 1): -1, (8, 2): 1, (8, 3): -1, (9, 0): 1, (9, 1): -1, (9, 2): -1, (9, 3): -1, (10, 0): 1, (10, 1): -1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): -1, (11, 2): -1, (11, 3): 1, (12, 0): -1, (12, 1): 1, (12, 2): -1, (12, 3): -1}
best_solution10 = {(0, 0): -1, (0, 1): -1, (0, 2): -1, (0, 3): 1, (1, 0): -1, (1, 1): -1, (1, 2): 1, (1, 3): -1, (2, 0): -1, (2, 1): 1, (2, 2): -1, (2, 3): -1, (3, 0): -1, (3, 1): -1, (3, 2): -1, (3, 3): 1, (4, 0): 1, (4, 1): -1, (4, 2): -1, (4, 3): -1, (5, 0): 1, (5, 1): -1, (5, 2): -1, (5, 3): -1, (6, 0): -1, (6, 1): 1, (6, 2): -1, (6, 3): -1, (7, 0): -1, (7, 1): -1, (7, 2): 1, (7, 3): -1, (8, 0): -1, (8, 1): -1, (8, 2): -1, (8, 3): 1, (9, 0): -1, (9, 1): -1, (9, 2): 1, (9, 3): -1, (10, 0): 1, (10, 1): -1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): -1, (11, 2): -1, (11, 3): 1, (12, 0): -1, (12, 1): -1, (12, 2): 1, (12, 3): -1}
best_solution5_2 = {(0, 0): -1, (0, 1): 1, (0, 2): -1, (0, 3): -1, (1, 0): -1, (1, 1): -1, (1, 2): 1, (1, 3): -1, (2, 0): -1, (2, 1): -1, (2, 2): -1, (2, 3): 1, (3, 0): 1, (3, 1): -1, (3, 2): -1, (3, 3): -1, (4, 0): 1, (4, 1): -1, (4, 2): -1, (4, 3): -1, (5, 0): -1, (5, 1): -1, (5, 2): -1, (5, 3): 1, (6, 0): -1, (6, 1): -1, (6, 2): 1, (6, 3): -1, (7, 0): 1, (7, 1): -1, (7, 2): -1, (7, 3): -1, (8, 0): -1, (8, 1): 1, (8, 2): -1, (8, 3): -1, (9, 0): -1, (9, 1): -1, (9, 2): 1, (9, 3): -1, (10, 0): -1, (10, 1): -1, (10, 2): 1, (10, 3): -1, (11, 0): -1, (11, 1): 1, (11, 2): -1, (11, 3): -1, (12, 0): 1, (12, 1): -1, (12, 2): -1, (12, 3): -1}

# Valid solutions
best_solution5 = {(0, 0): -1, (0, 1): -1, (0, 2): 1, (0, 3): -1, (1, 0): 1, (1, 1): -1, (1, 2): -1, (1, 3): -1, (2, 0): -1, (2, 1): -1, (2, 2): -1, (2, 3): 1, (3, 0): -1, (3, 1): 1, (3, 2): -1, (3, 3): -1, (4, 0): -1, (4, 1): 1, (4, 2): -1, (4, 3): -1, (5, 0): -1, (5, 1): -1, (5, 2): 1, (5, 3): -1, (6, 0): 1, (6, 1): -1, (6, 2): -1, (6, 3): -1, (7, 0): -1, (7, 1): -1, (7, 2): -1, (7, 3): 1, (8, 0): -1, (8, 1): -1, (8, 2): 1, (8, 3): -1, (9, 0): -1, (9, 1): 1, (9, 2): -1, (9, 3): -1, (10, 0): -1, (10, 1): 1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): -1, (11, 2): 1, (11, 3): -1, (12, 0): 1, (12, 1): -1, (12, 2): -1, (12, 3): -1}
best_solution3 = {(0, 0): -1, (0, 1): -1, (0, 2): -1, (0, 3): 1, (1, 0): 1, (1, 1): -1, (1, 2): -1, (1, 3): -1, (2, 0): -1, (2, 1): -1, (2, 2): 1, (2, 3): -1, (3, 0): -1, (3, 1): 1, (3, 2): -1, (3, 3): -1, (4, 0): -1, (4, 1): 1, (4, 2): -1, (4, 3): -1, (5, 0): 1, (5, 1): -1, (5, 2): -1, (5, 3): -1, (6, 0): -1, (6, 1): -1, (6, 2): 1, (6, 3): -1, (7, 0): -1, (7, 1): -1, (7, 2): -1, (7, 3): 1, (8, 0): 1, (8, 1): -1, (8, 2): -1, (8, 3): -1, (9, 0): -1, (9, 1): -1, (9, 2): 1, (9, 3): -1, (10, 0): -1, (10, 1): 1, (10, 2): -1, (10, 3): -1, (11, 0): 1, (11, 1): -1, (11, 2): -1, (11, 3): -1, (12, 0): -1, (12, 1): -1, (12, 2): -1, (12, 3): 1}
best_solution3_2 = {(0, 0): -1, (0, 1): 1, (0, 2): -1, (0, 3): -1, (1, 0): -1, (1, 1): -1, (1, 2): 1, (1, 3): -1, (2, 0): 1, (2, 1): -1, (2, 2): -1, (2, 3): -1, (3, 0): -1, (3, 1): -1, (3, 2): -1, (3, 3): 1, (4, 0): -1, (4, 1): -1, (4, 2): -1, (4, 3): 1, (5, 0): -1, (5, 1): -1, (5, 2): 1, (5, 3): -1, (6, 0): -1, (6, 1): 1, (6, 2): -1, (6, 3): -1, (7, 0): -1, (7, 1): -1, (7, 2): -1, (7, 3): 1, (8, 0): 1, (8, 1): -1, (8, 2): -1, (8, 3): -1, (9, 0): -1, (9, 1): 1, (9, 2): -1, (9, 3): -1, (10, 0): -1, (10, 1): 1, (10, 2): -1, (10, 3): -1, (11, 0): 1, (11, 1): -1, (11, 2): -1, (11, 3): -1, (12, 0): -1, (12, 1): -1, (12, 2): -1, (12, 3): 1}
best_solution3_3 = {(0, 0): -1, (0, 1): -1, (0, 2): -1, (0, 3): 1, (1, 0): 1, (1, 1): -1, (1, 2): -1, (1, 3): -1, (2, 0): -1, (2, 1): 1, (2, 2): -1, (2, 3): -1, (3, 0): -1, (3, 1): -1, (3, 2): -1, (3, 3): 1, (4, 0): -1, (4, 1): -1, (4, 2): -1, (4, 3): 1, (5, 0): -1, (5, 1): -1, (5, 2): 1, (5, 3): -1, (6, 0): 1, (6, 1): -1, (6, 2): -1, (6, 3): -1, (7, 0): -1, (7, 1): -1, (7, 2): -1, (7, 3): 1, (8, 0): -1, (8, 1): -1, (8, 2): 1, (8, 3): -1, (9, 0): -1, (9, 1): 1, (9, 2): -1, (9, 3): -1, (10, 0): -1, (10, 1): 1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): -1, (11, 2): 1, (11, 3): -1, (12, 0): -1, (12, 1): -1, (12, 2): -1, (12, 3): 1}
best_solution3_4 = {(0, 0): -1, (0, 1): 1, (0, 2): -1, (0, 3): -1, (1, 0): 1, (1, 1): -1, (1, 2): -1, (1, 3): -1, (2, 0): -1, (2, 1): -1, (2, 2): 1, (2, 3): -1, (3, 0): -1, (3, 1): 1, (3, 2): -1, (3, 3): -1, (4, 0): -1, (4, 1): 1, (4, 2): -1, (4, 3): -1, (5, 0): 1, (5, 1): -1, (5, 2): -1, (5, 3): -1, (6, 0): -1, (6, 1): -1, (6, 2): -1, (6, 3): 1, (7, 0): 1, (7, 1): -1, (7, 2): -1, (7, 3): -1, (8, 0): -1, (8, 1): -1, (8, 2): 1, (8, 3): -1, (9, 0): -1, (9, 1): 1, (9, 2): -1, (9, 3): -1, (10, 0): 1, (10, 1): -1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): -1, (11, 2): 1, (11, 3): -1, (12, 0): -1, (12, 1): -1, (12, 2): -1, (12, 3): 1}
best_solution3_5 = {(0, 0): 1, (0, 1): -1, (0, 2): -1, (0, 3): -1, (1, 0): -1, (1, 1): -1, (1, 2): 1, (1, 3): -1, (2, 0): -1, (2, 1): 1, (2, 2): -1, (2, 3): -1, (3, 0): 1, (3, 1): -1, (3, 2): -1, (3, 3): -1, (4, 0): 1, (4, 1): -1, (4, 2): -1, (4, 3): -1, (5, 0): -1, (5, 1): -1, (5, 2): -1, (5, 3): 1, (6, 0): -1, (6, 1): -1, (6, 2): 1, (6, 3): -1, (7, 0): 1, (7, 1): -1, (7, 2): -1, (7, 3): -1, (8, 0): -1, (8, 1): -1, (8, 2): 1, (8, 3): -1, (9, 0): 1, (9, 1): -1, (9, 2): -1, (9, 3): -1, (10, 0): 1, (10, 1): -1, (10, 2): -1, (10, 3): -1, (11, 0): -1, (11, 1): 1, (11, 2): -1, (11, 3): -1, (12, 0): -1, (12, 1): -1, (12, 2): -1, (12, 3): 1}
# fmt: on

best_solution = best_solution3_5

# Check that we have distinct colour for each region
for i in range(n_regions):
    s = 0
    for k in range(n_colours):
        s += best_solution[(i, k)]
    assert s == -n_colours + 2, f'Failed to find distinct colour for region {i}'
print('Each region has a distinct colour!')

# Get the colours associated to each region
region_colours = [np.argmax([best_solution[(i, k)] for k in range(n_colours)]) for i in range(n_regions)]

# Check that adjacent regions don't have the same colour
for i, j in graph.edges:
    assert (
        region_colours[i] != region_colours[j]
    ), f'{provinces[i]} and {provinces[j]} share a border but have the same colour!'
print('No neighbouring regions have the same colour!')

colour_strings = [
    'blue',
    'green',
    'red',
    'yellow',
    'cyan',
    'magenta',
    'black',
    'white',
    'orange',
    'purple',
    'pink',
    'brown',
    'grey',
    'olive',
    'teal',
    'hotpink',
]
colour_map = []
for node in graph:
    colour_map.append(colour_strings[region_colours[node]])

nx.draw(graph, node_color=colour_map, with_labels=True, labels=provinces)
plt.show()
